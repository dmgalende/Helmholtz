function data = run_boundary(data,handle)

% Some useful auxiliar variables and parameters
omega = 2*pi/data.ip.period;
nameNodal = data.mesh.fieldNames{data.mesh.indexElemPosCon(2)};
angle = data.ip.direction*(pi/180);
kvector = data.ip.waveNumberValue*[cos(angle) sin(angle)];
nOfBoundaries = numel(data.mesh.boundaryNames);
nOfBoundaryNodes = 0;
for iboundary = 1:nOfBoundaries
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    inOfBoundaryNodes = length(unique(data.mesh.(inameCon)));
    nOfBoundaryNodes = nOfBoundaryNodes + inOfBoundaryNodes;
end
if data.staticCondensation
    nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
    nOfNodes = size(data.mesh.(nameNodal),1) -...
        length(data.mesh.referenceElement.innerNodes)*...
        size(data.mesh.(nameCon),1);
else
    nOfNodes = size(data.mesh.(nameNodal),1);
end
nOfElementNodes = data.mesh.referenceElement.degree + 1;

% NRB matrix, damping matrix and reflecting vector from Berkhoff equation
boundaryMatrixSum = spalloc(nOfNodes,nOfNodes,nOfBoundaryNodes*nOfElementNodes); %Poor estimated NNZ entries, not important
boundaryVectorSum = zeros(nOfNodes,1);
t = cputime;
tic
for iboundary = 1:nOfBoundaries
    iname = data.mesh.boundaryNames{iboundary};
    icond = data.BC.values(iboundary);
    iparam = data.BC.parameters{iboundary}{icond};
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    setOutput({['Computation on boundary "' iname '":']},handle)
    
    if data.staticCondensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix_static(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg,...
                                          data.mesh.newFaceNodesNum,...
                                          nOfNodes);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector_static(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         kvector,...
                                         data.ip.amplitude,...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam,...
                                         data.mesh.newFaceNodesNum,...
                                         nOfNodes);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam,...
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99,... %Straight radiation boundary
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes); 
        end

    else %no static condensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         data.ip.value,...
                                         data.ip.gradientsIP.(iname),...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam);

        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99); %Straight radiation boundary
        end
    end
end

% Vector on the interior boundary (without PML)
if data.staticCondensation
    
else
    boundaryVectorSum = boundaryVectorSum -...
                berkhoffInteriorVector(data.mesh.(nameNodal),...
                                       data.mesh.intTb,...
                                       data.mesh.referenceElement,...
                                       data.ip.gradientsIP.intTb,...
                                       data.bottom.ccg);
end

data.cputime.boundaryToc = toc;
data.cputime.boundary = cputime - t;

% Solution to the linear system
setOutput({'Solving the linear system...'},handle)
A = data.mesh.MminusK + boundaryMatrixSum;
f = boundaryVectorSum - data.mesh.fvolume;
t = cputime;
tic
[L,U,P,Q] = lu(A); %Call UMFPACK
data.solution = Q*(U\(L\(P*f)));
data.cputime.linearSystemToc = toc;
data.cputime.linearSystem = cputime - t;

%Postprocess solution at inner nodes if static condensation is used
if data.staticCondensation
    setOutput({'Postprocessing solution at inner nodes...'},handle)
    data.solution = postprocessInnerNodesSolution_static(data.mesh.(nameCon),...
        data.mesh.elementalInnerInfo,...
        data.mesh.newFaceNodesNum,...
        data.solution,...
        data.mesh.referenceElement);
end
        



