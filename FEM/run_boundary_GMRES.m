function data = run_boundary(data,handle)

% Some useful auxiliar variables and parameters
nameNodal = data.mesh.fieldNames{data.mesh.indexElemPosCon(2)};
angle = data.ip.direction*(pi/180);
kvector = data.ip.waveNumberValue*[cos(angle) sin(angle)];
nOfBoundaries = numel(data.mesh.boundaryNames);
nOfBoundaryNodes = 0;
for iboundary = 1:nOfBoundaries
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    inOfBoundaryNodes = length(unique(data.mesh.(inameCon)));
    nOfBoundaryNodes = nOfBoundaryNodes + inOfBoundaryNodes;
end
if data.staticCondensation
    nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
    nOfNodes = size(data.mesh.(nameNodal),1) -...
        length(data.mesh.referenceElement.innerNodes)*...
        size(data.mesh.(nameCon),1);
else
    nOfNodes = size(data.mesh.(nameNodal),1);
end
nOfElementNodes = data.mesh.referenceElement.degree + 1;

% NRB matrix, damping matrix and reflecting vector from Berkhoff equation
boundaryMatrixSum = spalloc(nOfNodes,nOfNodes,nOfBoundaryNodes*nOfElementNodes); %Poor estimated NNZ entries, not important
boundaryVectorSum = zeros(nOfNodes,1);
t = cputime;
tic
for iboundary = 1:nOfBoundaries
    iname = data.mesh.boundaryNames{iboundary};
    icond = data.BC.values(iboundary);
    iparam = data.BC.parameters{iboundary}{icond};
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    setOutput({['Computation on boundary "' iname '":']},handle)
    
    if data.staticCondensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix_static(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg,...
                                          data.mesh.newFaceNodesNum,...
                                          nOfNodes);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector_static(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         kvector,...
                                         data.ip.amplitude,...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam,...
                                         data.mesh.newFaceNodesNum,...
                                         nOfNodes);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam,...
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99,... %Straight radiation boundary
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes); 
        end

    else %no static condensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         kvector,...
                                         data.ip.amplitude,...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99); %Straight radiation boundary
        end
    end
end
data.cputime.boundaryToc = toc;
data.cputime.boundary = cputime - t;

% Linear system
A = data.mesh.MminusK + boundaryMatrixSum;
f = boundaryVectorSum - data.mesh.fvolume;
data.iterSolver.nnz = nnz(A);
data.iterSolver.condnumber = condest(A);

% ILU Preconditioner
if strcmpi(data.iterSolver.ilusetup.type,'noprec')
    L = [];
    U = [];
else
    tic
    t = cputime;
    setOutput({'Computing ILU Preconditioner...'},handle)
    [L,U] = ilu(A,data.iterSolver.ilusetup);
    data.iterSolver.cputimeprec.toc = toc;
    data.iterSolver.cputimeprec.cputime = cputime - t;
end
data.iterSolver.solver = 'GMRES';
data.iterSolver.x0 = transpose(data.ip.amplitude*exp(sqrt(-1)*kvector*(data.mesh.(nameNodal))'));
if data.staticCondensation
    data.iterSolver.x0 = data.iterSolver.x0(data.mesh.newFaceNodesNum > 0);
end

% Solving the linear system
setOutput({'Solving the linear system (GMRES)...'},handle)
t = cputime;
tic
[data.solution,flag,relres,iter,resvec] = ...
    gmres(A,f,data.iterSolver.restart,data.iterSolver.tol,data.iterSolver.maxiter,L,U,data.iterSolver.x0);
data.cputime.linearSystemToc = toc;
data.cputime.linearSystem = cputime - t;
data.iterSolver.flag = flag;
data.iterSolver.iter = iter;
data.iterSolver.resvec = resvec;
data.iterSolver.relres = relres;

%Postprocess solution at inner nodes if static condensation is used
if data.staticCondensation
    setOutput({'Postprocessing solution at inner nodes...'},handle)
    data.solution = postprocessInnerNodesSolution_static(data.mesh.(nameCon),...
        data.mesh.elementalInnerInfo,...
        data.mesh.newFaceNodesNum,...
        data.solution,...
        data.mesh.referenceElement);
end
        



