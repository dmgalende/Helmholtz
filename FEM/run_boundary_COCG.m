function data = run_boundary(data,handle)

% Some useful auxiliar variables and parameters
nameNodal = data.mesh.fieldNames{data.mesh.indexElemPosCon(2)};
angle = data.ip.direction*(pi/180);
kvector = data.ip.waveNumberValue*[cos(angle) sin(angle)];
nOfBoundaries = numel(data.mesh.boundaryNames);
nOfBoundaryNodes = 0;
for iboundary = 1:nOfBoundaries
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    inOfBoundaryNodes = length(unique(data.mesh.(inameCon)));
    nOfBoundaryNodes = nOfBoundaryNodes + inOfBoundaryNodes;
end
if data.staticCondensation
    nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
    nOfNodes = size(data.mesh.(nameNodal),1) -...
        length(data.mesh.referenceElement.innerNodes)*...
        size(data.mesh.(nameCon),1);
else
    nOfNodes = size(data.mesh.(nameNodal),1);
end
nOfElementNodes = data.mesh.referenceElement.degree + 1;

% NRB matrix, damping matrix and reflecting vector from Berkhoff equation
boundaryMatrixSum = spalloc(nOfNodes,nOfNodes,nOfBoundaryNodes*nOfElementNodes); %Poor estimated NNZ entries, not important
boundaryVectorSum = zeros(nOfNodes,1);
t = cputime;
tic
for iboundary = 1:nOfBoundaries
    iname = data.mesh.boundaryNames{iboundary};
    icond = data.BC.values(iboundary);
    iparam = data.BC.parameters{iboundary}{icond};
    inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
    setOutput({['Computation on boundary "' iname '":']},handle)
    
    if data.staticCondensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix_static(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg,...
                                          data.mesh.newFaceNodesNum,...
                                          nOfNodes);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector_static(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         kvector,...
                                         data.ip.amplitude,...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam,...
                                         data.mesh.newFaceNodesNum,...
                                         nOfNodes);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam,...
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_static(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99,... %Straight radiation boundary
                                   data.mesh.newFaceNodesNum,...
                                   nOfNodes); 
        end

    else %no static condensation
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix(data.mesh.(nameNodal),...
                                          data.mesh.(inameCon),...
                                          data.mesh.referenceElement,...
                                          data.bottom.waveNumber,...
                                          data.bottom.ccg);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector(data.mesh.(nameNodal),...
                                         data.mesh.(inameCon),...
                                         data.mesh.referenceElement,...
                                         kvector,...
                                         data.ip.amplitude,...
                                         data.bottom.waveNumber,...
                                         data.bottom.ccg,...
                                         iparam);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   iparam);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix(data.mesh.(nameNodal),...
                                   data.mesh.(inameCon),...
                                   data.mesh.referenceElement,...
                                   data.bottom.waveNumber,...
                                   data.bottom.ccg,...
                                   1e99); %Straight radiation boundary
        end
    end
end
data.cputime.boundaryToc = toc;
data.cputime.boundary = cputime - t;

% Solution to the linear system
setOutput({'Solving the linear system...'},handle)
A = data.mesh.MminusK + boundaryMatrixSum;
f = boundaryVectorSum - data.mesh.fvolume;
data.iterSolver.solver = 'Conjugate Gradients';
data.iterSolver.x0 = transpose(data.ip.amplitude*exp(sqrt(-1)*kvector*(data.mesh.(nameNodal))'));
if data.staticCondensation
    data.iterSolver.x0 = data.iterSolver.x0(data.mesh.newFaceNodesNum > 0);
end
data.iterSolver.nmax = 2*size(data.iterSolver.x0,1);
data.iterSolver.tol = 1e-6;

t = cputime;
tic
[data.solution,flag,iter,errorVec] = ...
    conjugateGradients(A,f,data.iterSolver.x0,data.iterSolver.nmax,data.iterSolver.tol);
data.cputime.linearSystemToc = toc;
data.cputime.linearSystem = cputime - t;

data.iterSolver.converged = flag;
data.iterSolver.iter = iter;
data.iterSolver.error = errorVec;
if flag == 1
    setOutput({['CG has converged in ' num2str(iter) ' iterations'...
        ' with a tolerance of ' num2str(data.iterSolver.tol)]},handle)
elseif flag == 0
    setOutput({['CG has NOT converged in ' num2str(iter) ' iterations'...
        ' with an error of ' num2str(errorVec(end))]},handle)
elseif flag == 2
    setOutput({['CG has FAILED in ' num2str(iter) ' iterations due to a very small'...
        ' scalar quantity']},handle)
end

%Postprocess solution at inner nodes if static condensation is used
if data.staticCondensation
    setOutput({'Postprocessing solution at inner nodes...'},handle)
    data.solution = postprocessInnerNodesSolution_static(data.mesh.(nameCon),...
        data.mesh.elementalInnerInfo,...
        data.mesh.newFaceNodesNum,...
        data.solution,...
        data.mesh.referenceElement);
end
        



