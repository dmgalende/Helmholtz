function data = run_boundary_CDG(data,handle)

% Some useful auxiliar variables and parameters
nameNodal = data.mesh.fieldNames{data.mesh.indexElemPosCon(2)};
nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
angle = data.ip.direction*(pi/180);
kvector = data.ip.waveNumberValue*[cos(angle) sin(angle)];
nOfBoundaries = numel(data.mesh.boundaryNames);

% NRB matrix, damping matrix and reflecting vector from Berkhoff equation

if isfield(data,'p_adaptivity')
    dim = size(data.mesh.KminusMplusH,1);
    boundaryMatrixSum = spalloc(dim,dim,3*dim);
    boundaryVectorSum = zeros(dim,1);
    t = cputime;
    for iboundary = 1:nOfBoundaries
        iname = data.mesh.boundaryNames{iboundary};
        nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
        icond = data.BC.values(iboundary);
        iparam = data.BC.parameters{iboundary}{icond};
        %     inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
        setOutput({['Computation on boundary "' iname '":']},handle)
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix_CDG_P_adapt(data.mesh.(nameNodal),...
                    data.mesh.(nameCon),...
                    data.mesh.referenceElement,...
                    data.infoFaces.(['exteriorFaces_' iname]),...
                    data.bottom.waveNumber,...
                    data.bottom.ccg,data.p_adaptivity);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector_CDG_P_adapt(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                kvector,...
                data.ip.amplitude,...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                iparam,data.p_adaptivity);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_CDG_P_adapt(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                iparam,data.p_adaptivity);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_CDG_P_adapt(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                1e99,data.p_adaptivity); %Straight radiation boundary
        end
    end
    data.cputime.boundary = cputime - t;
else
    numelT = numel(data.mesh.(nameCon));
    boundaryMatrixSum = spalloc(numelT,numelT,3*numelT);
    boundaryVectorSum = zeros(numelT,1);
    t = cputime;
    for iboundary = 1:nOfBoundaries
        iname = data.mesh.boundaryNames{iboundary};
        nameCon = data.mesh.fieldNames{data.mesh.indexElemPosCon(3)};
        icond = data.BC.values(iboundary);
        iparam = data.BC.parameters{iboundary}{icond};
        %     inameCon = data.mesh.fieldNames{data.mesh.boundaryIndex(iboundary)};
        setOutput({['Computation on boundary "' iname '":']},handle)
        if icond == 1
            % Do nothing, it is a natural boundary condition of FEM
            setOutput({'       Natural boundary condition'},handle)
        elseif icond == 2
            if iparam
                setOutput({'       Damping matrix...'},handle)
                boundaryMatrixSum = boundaryMatrixSum + sqrt(-1)*iparam*...
                    berkhoffDampingMatrix_CDG(data.mesh.(nameNodal),...
                    data.mesh.(nameCon),...
                    data.mesh.referenceElement,...
                    data.infoFaces.(['exteriorFaces_' iname]),...
                    data.bottom.waveNumber,...
                    data.bottom.ccg);
            end
            setOutput({'       Reflecting vector...'},handle)
            boundaryVectorSum = boundaryVectorSum +...
                berkhoffReflectingVector_CDG(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                kvector,...
                data.ip.amplitude,...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                iparam);
        elseif icond == 3
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_CDG(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                iparam);
        elseif icond == 4
            setOutput({'       Non reflecting boundary matrix...'},handle)
            boundaryMatrixSum = boundaryMatrixSum +...
                berkhoffNRBCMatrix_CDG(data.mesh.(nameNodal),...
                data.mesh.(nameCon),...
                data.mesh.referenceElement,...
                data.infoFaces.(['exteriorFaces_' iname]),...
                data.bottom.waveNumber,...
                data.bottom.ccg,...
                1e99); %Straight radiation boundary
        end
    end
    data.cputime.boundary = cputime - t;
end
% Solution to the linear system
setOutput({'Solving the linear system...'},handle)
A = data.mesh.KminusMplusH - boundaryMatrixSum;
f = data.mesh.fvolume -boundaryVectorSum;
t = cputime;
data.solution = A\f;
data.cputime.linearSystem = cputime - t;
% data.mesh = rmfield(data.mesh,{'KminusMplusH' 'fvolume'});


